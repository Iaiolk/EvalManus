# Manus自主规划层工作流程简化说明

## 核心功能

Manus自主规划层可以自动将复杂任务分解为步骤，然后协调多个AI代理逐步完成。

## 主要组件

### PlanningFlow - 主控制器

- 接收任务输入
- 生成执行计划
- 协调代理执行
- 跟踪进度状态

### PlanningTool - 计划管理工具

- `create` - 创建计划
- `mark_step` - 更新步骤状态
- `get` - 获取计划信息

### 步骤状态

- `[ ]` 未开始
- `[→]` 进行中
- `[✓]` 已完成
- `[!]` 已阻塞

## 详细工作流程

### 阶段1: 初始化与验证

#### 1.1 开始执行

```python
async def execute(self, input_text: str) -> str:
```

- 接收用户输入的任务描述
- 验证主代理是否可用
- 准备开始执行流程

#### 1.2 输入验证

- 检查输入文本是否有效
- 如果有输入，触发计划创建流程
- 如果无输入，使用现有计划继续执行

### 阶段2: 计划创建流程

#### 2.1 LLM驱动的计划创建

```python
async def _create_initial_plan(self, request: str) -> None:
```

**系统消息设置**:

```
你是一个规划助手。创建一个简洁、可操作的计划，包含清晰的步骤。
专注于关键里程碑而不是详细的子步骤。
优化清晰度和效率。
```

**用户消息构建**:

```
创建一个合理的计划，包含清晰的步骤来完成任务: {request}
```

#### 2.2 PlanningTool执行

- LLM调用`planning`工具的`create`命令
- 自动生成计划ID（`plan_{timestamp}`）
- 解析LLM返回的计划结构
- 创建步骤状态跟踪

#### 2.3 默认计划机制

如果LLM调用失败，系统会创建默认计划：

```python
{
    "command": "create",
    "plan_id": self.active_plan_id,
    "title": f"计划: {request[:50]}{'...' if len(request) > 50 else ''}",
    "steps": ["分析请求", "执行任务", "验证结果"]
}
```

#### 2.4 计划验证

- 检查计划是否成功创建
- 验证`active_plan_id`在`planning_tool.plans`中存在
- 失败时返回错误信息

### 阶段3: 主执行循环

#### 3.1 获取当前步骤信息

```python
async def _get_current_step_info(self) -> tuple[Optional[int], Optional[dict]]:
```

**步骤识别逻辑**:

1. 遍历计划中的所有步骤
2. 查找状态为`NOT_STARTED`或`IN_PROGRESS`的步骤
3. 提取步骤类型（如`[SEARCH]`、`[CODE]`标签）
4. 将选中步骤标记为`IN_PROGRESS`

**步骤信息结构**:

```python
step_info = {
    "text": "步骤描述文本",
    "type": "步骤类型（可选）"
}
```

#### 3.2 执行器选择

```python
def get_executor(self, step_type: Optional[str] = None) -> BaseAgent:
```

**选择策略**:

1. 如果步骤有特定类型且匹配可用代理，使用该代理
2. 遍历`executor_keys`列表，选择第一个可用代理
3. 最后回退到`primary_agent`

#### 3.3 步骤执行

```python
async def _execute_step(self, executor: BaseAgent, step_info: dict) -> str:
```

**执行流程**:

1. **准备上下文**: 获取当前计划状态
2. **构建提示**: 创建包含计划状态和当前任务的提示
3. **代理执行**: 调用`executor.run(step_prompt)`
4. **标记完成**: 成功后将步骤标记为`COMPLETED`

**提示模板**:

```
当前计划状态:
{plan_status}

您当前的任务:
您现在正在处理步骤 {step_index}: "{step_text}"

请使用适当的工具执行此步骤。完成后，提供一个关于您完成了什么的摘要。
```

#### 3.4 状态检查与循环控制

- 检查代理状态是否为`AgentState.FINISHED`
- 如果代理要求终止，退出循环
- 否则继续下一个步骤

### 阶段4: 计划完成流程

#### 4.1 获取最终计划状态

```python
async def _get_plan_text(self) -> str:
```

**状态报告包含**:

- 计划标题和ID
- 完成进度百分比
- 各状态步骤统计
- 详细步骤列表与状态标记

#### 4.2 LLM生成执行摘要

```python
async def _finalize_plan(self) -> str:
```

**摘要生成**:

- 使用系统LLM分析最终计划状态
- 生成工作完成摘要
- 提供最终思考和建议

**系统消息**:

```
你是一个规划助手。你的任务是总结已完成的计划。
```

#### 4.3 错误恢复机制

如果LLM摘要失败：

1. 回退到使用主代理生成摘要
2. 如果代理也失败，返回基本完成信息

## 关键特性解析

### 1. 智能步骤管理

- **状态跟踪**: 每个步骤都有明确的状态标识
- **进度可视化**: 使用Unicode符号显示步骤状态
- **灵活更新**: 支持步骤状态和备注的动态更新

### 2. 多代理协调

- **类型匹配**: 根据步骤类型选择合适的执行代理
- **负载均衡**: 在多个执行器之间分配任务
- **故障转移**: 自动回退到主代理

### 3. 错误处理与恢复

- **默认计划**: LLM失败时的备用计划机制
- **状态同步**: 工具调用失败时的直接状态更新
- **日志记录**: 详细的错误日志和调试信息

### 4. 计划持久化

- **内存存储**: 计划数据存储在`PlanningTool.plans`字典中
- **状态保持**: 步骤状态和备注持久化
- **ID管理**: 基于时间戳的唯一计划ID

## 工作流优势

### 1. 可扩展性

- 易于添加新的步骤类型
- 支持插件式代理扩展
- 灵活的工具集成

### 2. 可靠性

- 多层错误恢复机制
- 状态一致性保证
- 详细的执行日志

### 3. 智能化

- LLM驱动的计划生成
- 自适应执行策略
- 智能代理选择

### 4. 可观测性

- 实时进度跟踪
- 详细状态报告
- 可视化状态标记

## 使用示例

### 典型使用场景

```python
# 创建规划流程
planning_flow = PlanningFlow(agents={"main": main_agent, "search": search_agent})

# 执行任务
result = await planning_flow.execute("分析用户行为数据并生成报告")
```

### 计划输出示例

```
计划: 分析用户行为数据并生成报告 (ID: plan_1703123456)
===============================================================

进度: 2/4 步骤已完成 (50.0%)
状态: 2 已完成, 1 进行中, 0 已阻塞, 1 未开始

步骤:
0. [✓] 收集用户行为数据
1. [✓] 清洗和预处理数据
2. [→] 进行数据分析
3. [ ] 生成分析报告
```

## 总结

Manus自主规划层通过精心设计的工作流程，实现了从任务输入到结果输出的全自动化处理。它结合了LLM的智能规划能力、多代理的协作执行、以及完善的状态管理机制，为复杂任务的自动化执行提供了强有力的支持。

这个系统的设计体现了现代AI系统的几个重要特征：智能化、可靠性、可扩展性和可观测性，为构建企业级AI应用提供了坚实的基础。
